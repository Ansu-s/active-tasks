 <div style="text-align:center">

# Logging in java

 </div>

## Why logging is used :

Keeping  track of application's flow of execution  is called as logging.We can monitor the applications different stages of execution using a logger.
Using the logger generated messages we can find the state of the application execution at any given time and date.
Logging keeps track of the operations occurring in the application.  

Java application development, logging is typically implemented using libraries like Log4j, Logback, or the built-in java.util.logging package. These libraries offer various configuration options, log levels, and output destinations (e.g., console, files, databases) to tailor logging to the specific needs of the application and the DevOps pipeline. Effective logging practices, including proper log level management and log rotation, are crucial to ensure that logs remain useful and do not consume excessive storage space.  

Logging plays an essential role in the below topics
- Debugging and Troubleshooting
- Monitoring and Alert
- Auditing and compliance purpose
- Performance analysis
- User behaviour analysis
- Security
- Historical record maintenance
- Version Control

# What is slf4j or logback :

SLF4J (Simple Logging Facade for Java) and Logback are two popular libraries used in Java for logging. They serve different purposes within the logging ecosystem:

1. **SLF4J (Simple Logging Facade for Java)**:
    - SLF4J is an abstraction layer or facade for various logging frameworks in Java.
    - It provides a simple and consistent API for logging so that developers can write code that is not tied to a specific logging implementation.
    - Developers use SLF4J to log messages, but they can choose different underlying logging implementations (such as Logback, Log4j, or java.util.logging) at runtime by providing the corresponding implementation on the classpath.
    - SLF4J is widely used in Java projects to decouple the application code from the actual logging framework, making it easier to switch or configure logging implementations as needed.

2. **Logback**:
    - Logback is an actual logging framework that can be used as the implementation behind SLF4J.
    - It offers high-performance and flexibility for logging in Java applications.
    - Logback includes three main components: Logback Core (provides the basic logging infrastructure), Logback Classic (implements the SLF4J API and offers similar features to Log4j), and Logback Access (for HTTP access log generation).
    - Logback is known for its configurability, including support for various output destinations (e.g., console, files, databases) and log rotation.

## Logging Levels  

Logging levels are a way to categorize log messages based on their severity or importance. They help in controlling the amount of information generated by a logging system and allow developers and operations teams to filter and prioritize log messages effectively. In most logging frameworks, including popular ones like Logback and Log4j, there are several standard logging levels, each with its own significance:

1. **TRACE**: The lowest and most detailed level of logging. TRACE messages are typically used for extremely fine-grained debugging information. These messages can help developers trace the flow of code and identify specific issues but can generate a lot of data.

2. **DEBUG**: Used for debugging and development purposes. DEBUG messages provide detailed information about what the application is doing internally. These messages are valuable during development but are usually not enabled in production environments due to their volume.

3. **INFO**: Informational messages that signify significant events in the application's lifecycle. INFO messages are often used to record when the application starts, stops, or reaches critical milestones. They provide a high-level overview of the application's behavior.

4. **WARN (Warning)**: Indicates potential issues or situations that require attention but do not necessarily disrupt the application's functionality. WARN messages are used to highlight issues that should be addressed to prevent future problems.

5. **ERROR**: Represents errors or exceptions that occur during the application's execution. ERROR messages indicate that something went wrong, but the application can usually continue running. These messages are crucial for identifying and diagnosing problems.

6. **FATAL (or CRITICAL)**: The highest level of severity, representing critical errors that typically lead to the application's termination or shutdown. FATAL messages indicate a severe failure that requires immediate attention. Not all logging frameworks have a FATAL level; it's sometimes treated as a synonym for ERROR.

7. **OFF**: A special level that turns off logging entirely. No log messages are generated when the logging level is set to OFF. This level is used to disable logging entirely for specific components or in specific environments.

8. **ALL**: Another special level that captures all log messages, regardless of their level. This level is rarely used and is generally reserved for debugging specific issues.

Developers can configure the logging level for different parts of their application or for specific loggers or appenders. For example, in a production environment, you might set the logging level to INFO or higher to limit the volume of log data while still capturing important information and errors. In a development or debugging scenario, you might set the logging level to DEBUG or TRACE to gain more detailed insights into the application's behavior. Logging levels play a crucial role in managing the verbosity and usefulness of log output.
<div align="center">


| No | Logger Level    | Priority | Summary                                       | 
|----|-----------------|----------|-----------------------------------------------|
| 1  | TRACE           | Lowest   | Very detailed debugging information           |
| 2  | DEBUG           | Low      | Debugging and development information         |
| 3  | INFO            | Moderate | Significant application events                |
| 4  | WARN            | Moderate | Potential issues requiring attention          |
| 5  | ERROR           | High     | Errors or exceptions during execution         |
| 6  | FATAL (CRITICAL | Highest  | Critical errors requiring immediate attention |
| 7  | OFF             | Special  | Logging is entirely turned off                |
| 8  | ALL             | Special  | Captures all log messages                     |

</div>

## What is a appender in java log-file :

In Java logging frameworks like Logback, Log4j, and java.util.logging, an appender is a component responsible for specifying where log messages should be sent or "appended." Appenders are a fundamental part of a logging configuration and determine the destination of log output. Here's an overview of what appenders are and how they work:

1. **Destination for Log Messages**: An appender defines the target or destination for log messages generated by the application. Common destinations include the console, log files, databases, email, or remote servers.

2. **Configurable Behavior**: Each appender can be configured with specific behaviors. For example, you can set the format of log messages, specify log file rotation policies, define filtering rules to select which messages should be logged, and more.

3. **Multiple Appenders**: An application can have multiple appenders configured simultaneously. This allows you to send log messages to different destinations simultaneously. For example, you can log errors to a file and informational messages to the console.

4. **Appender Types**: There are various types of appenders available in logging frameworks, each designed for a specific use case. Common types include:
    - **Console Appender**: Sends log messages to the console or terminal.
    - **File Appender**: Writes log messages to a file.
    - **Rolling File Appender**: Similar to a file appender but with log file rotation to manage file size.
    - **SMTP Appender**: Sends log messages via email.
    - **Database Appender**: Stores log messages in a database.
    - **Socket Appender**: Sends log messages to a remote server over a network socket.

5. **Logger Configuration**: Appenders are associated with loggers, which are components that categorize log messages based on their source or functionality within the application. When you configure an appender, you typically specify which logger(s) should use it.

The below  example tells us how you might configure a file appender in a logging framework like Logback:

```xml
<configuration>
    <appender name="FileAppender" class="ch.qos.logback.core.FileAppender">
        <file>application.log</file> <!-- Specify the log file name -->
        <encoder>
            <pattern>%d [%thread] %-5level %logger - %msg%n</pattern> <!-- Define log message format -->
        </encoder>
    </appender>

    <!-- Attach the appender to a logger -->
    <root level="INFO">
        <appender-ref ref="FileAppender" />
    </root>
</configuration>
```

In the above example, a FileAppender is configured to write log messages to a file called "application.log" with a specified log message format. The appender is then attached to the root logger with a minimum log level of INFO.

By using appenders and configuring them according to your needs, you can control where and how log messages are stored and delivered in your Java application, which is crucial for debugging, monitoring, and analyzing the application's behavior.

## Logger rollback policies

Rolling policies in java frameworks like Logback or Log4j, define how log files are managed and rotated to ensure that log data remains organized, manageable, and doesn't consume excessive storage space. There are several common rolling policies available, each with its own approach to managing log files:

1. **Size-Based Rolling Policy**:
   - This policy rotates log files when they reach a certain size threshold.
   - For example, you can configure log files to roll over to a new file when they reach a specific size, such as 1 MB.
   - Old log files are typically archived or renamed with a timestamp to preserve them.

2. **Time-Based Rolling Policy**:
   - This policy rotates log files at specific time intervals, such as daily, weekly, or monthly.
   - Log files are created for each time interval, and old log files are archived or renamed.

3. **Composite Rolling Policy**:
   - This policy combines both size-based and time-based criteria for log rotation.
   - It allows log files to roll over based on either size or time, whichever criterion is met first.

4. **Fixed Window Rolling Policy**:
   - This policy maintains a fixed number of log files, rolling over to a new file when the maximum count is reached.
   - Old log files are removed once the maximum count is exceeded.

5. **Triggering Policies**:
   - Some rolling policies are triggered by specific events or conditions.
   - For example, you can configure log rolling when a specific error occurs, ensuring that logs are captured around critical events.

6. **Custom Rolling Policies**:
   - Logging frameworks often allow developers to create custom rolling policies based on specific requirements.
   - Custom policies can be designed to roll log files based on application-specific logic.

Here's an example of configuring a rolling policy in Logback using a size-based policy:

```xml
<appender name="FileAppender" class="ch.qos.logback.core.rolling.RollingFileAppender">
    <file>myapp.log</file>
    <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
        <fileNamePattern>myapp.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
        <maxFileSize>1MB</maxFileSize>
        <maxHistory>7</maxHistory>
    </rollingPolicy>
    <encoder>
        <pattern>%date [%level] [%thread] %logger{10} [%file:%line] - %msg%n</pattern>
    </encoder>
</appender>
```

In this example, the `SizeAndTimeBasedRollingPolicy` is used to roll log files based on both size (`maxFileSize`) and time (`fileNamePattern`). It keeps up to 7 days' worth of log files with a maximum file size of 1 MB each.

Different logging frameworks may have variations in rolling policy configuration, so it's essential to consult the documentation specific to the framework you are using to configure rolling policies effectively.